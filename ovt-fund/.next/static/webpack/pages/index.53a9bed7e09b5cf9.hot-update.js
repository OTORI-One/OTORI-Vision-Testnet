"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/hooks/useOVTClient.ts":
/*!***********************************!*\
  !*** ./src/hooks/useOVTClient.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOVTClient: function() { return /* binding */ useOVTClient; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_archClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/archClient */ \"./src/lib/archClient.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n\n\n// Initialize the Arch client\nconst archClient = new _lib_archClient__WEBPACK_IMPORTED_MODULE_1__.ArchClient({\n    programId: process.env.NEXT_PUBLIC_PROGRAM_ID || \"\",\n    treasuryAddress: process.env.NEXT_PUBLIC_TREASURY_ADDRESS || \"\",\n    endpoint: process.env.NEXT_PUBLIC_ARCH_ENDPOINT || \"http://localhost:8000\"\n});\n// Mock initial portfolio data\nconst INITIAL_PORTFOLIO_ITEMS = [\n    {\n        name: \"Polymorphic Labs\",\n        value: 200000,\n        current: 1040000,\n        change: 420,\n        description: \"Encryption Layer\"\n    },\n    {\n        name: \"VoltFi\",\n        value: 150000,\n        current: 525000,\n        change: 250,\n        description: \"Bitcoin Volatility Index on Bitcoin\"\n    },\n    {\n        name: \"MIXDTape\",\n        value: 100000,\n        current: 250000,\n        change: 150,\n        description: \"Phygital Music for superfans - disrupting Streaming\"\n    }\n];\n// Simulate portfolio value changes\nfunction simulatePortfolioChange(items) {\n    return items.map((item)=>({\n            ...item,\n            current: item.current * (1 + (Math.random() * 0.02 - 0.01)),\n            change: Number(((item.current / item.value - 1) * 100).toFixed(1))\n        }));\n}\nfunction useOVTClient() {\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [navData, setNavData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        totalValue: \"$1.815M\",\n        changePercentage: \"+302%\",\n        portfolioItems: INITIAL_PORTFOLIO_ITEMS\n    });\n    // Fetch NAV data periodically\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const fetchNAV = async ()=>{\n            try {\n                const nav = await archClient.getCurrentNAV();\n                const totalValue = nav.value;\n                const averageChange = nav.portfolioItems.reduce((sum, item)=>sum + item.change, 0) / nav.portfolioItems.length;\n                setNavData({\n                    totalValue: \"$\".concat((totalValue / 1000000).toFixed(3), \"M\"),\n                    changePercentage: \"\".concat(averageChange >= 0 ? \"+\" : \"\").concat(averageChange.toFixed(1), \"%\"),\n                    portfolioItems: nav.portfolioItems.map((item)=>({\n                            name: item.name,\n                            value: item.value,\n                            current: item.value * (1 + item.change / 100),\n                            change: item.change,\n                            description: getProjectDescription(item.name)\n                        }))\n                });\n            } catch (err) {\n                console.error(\"Failed to fetch NAV:\", err);\n            }\n        };\n        fetchNAV(); // Initial fetch\n        const interval = setInterval(fetchNAV, 30000); // Update every 30 seconds\n        return ()=>clearInterval(interval);\n    }, []);\n    const buyOVT = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (amount)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            // In a real implementation, we would:\n            // 1. Get the connected wallet address\n            // 2. Wait for the Bitcoin payment transaction\n            // 3. Use the payment txid to verify and complete the purchase\n            const mockPaymentTxid = \"mock_txid_\" + Date.now();\n            const result = await archClient.buyOVT(amount, mockPaymentTxid, \"mock_wallet_address\");\n            if (!result.success) {\n                throw new Error(result.error || \"Failed to buy OVT\");\n            }\n            // Refresh NAV data after successful purchase\n            await archClient.getCurrentNAV();\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to buy OVT\");\n            throw err;\n        } finally{\n            setIsLoading(false);\n        }\n    }, []);\n    const sellOVT = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (amount)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const result = await archClient.sellOVT(amount, \"mock_wallet_address\");\n            if (!result.success) {\n                throw new Error(result.error || \"Failed to sell OVT\");\n            }\n            // Refresh NAV data after successful sale\n            await archClient.getCurrentNAV();\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to sell OVT\");\n            throw err;\n        } finally{\n            setIsLoading(false);\n        }\n    }, []);\n    return {\n        isLoading,\n        error,\n        navData,\n        buyOVT,\n        sellOVT\n    };\n}\n// Helper function to get project descriptions\nfunction getProjectDescription(name) {\n    const descriptions = {\n        \"Polymorphic Labs\": \"Encryption Layer\",\n        \"VoltFi\": \"Bitcoin Volatility Index on Bitcoin\",\n        \"MIXDTape\": \"Phygital Music for superfans - disrupting Streaming\"\n    };\n    return descriptions[name] || \"\";\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q3BCLFVBQVU7UUFDVixZQUFZO0lBQ2Q7SUFDQSxPQUFPQSxZQUFZLENBQUM5QyxLQUFLLElBQUk7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZU9WVENsaWVudC50cz80N2QyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQXJjaENsaWVudCB9IGZyb20gJy4uL2xpYi9hcmNoQ2xpZW50JztcblxuaW50ZXJmYWNlIFBvcnRmb2xpbyB7XG4gIG5hbWU6IHN0cmluZztcbiAgdmFsdWU6IG51bWJlcjtcbiAgY3VycmVudDogbnVtYmVyO1xuICBjaGFuZ2U6IG51bWJlcjtcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE5BVkRhdGEge1xuICB0b3RhbFZhbHVlOiBzdHJpbmc7XG4gIGNoYW5nZVBlcmNlbnRhZ2U6IHN0cmluZztcbiAgcG9ydGZvbGlvSXRlbXM6IFBvcnRmb2xpb1tdO1xufVxuXG4vLyBJbml0aWFsaXplIHRoZSBBcmNoIGNsaWVudFxuY29uc3QgYXJjaENsaWVudCA9IG5ldyBBcmNoQ2xpZW50KHtcbiAgcHJvZ3JhbUlkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19QUk9HUkFNX0lEIHx8ICcnLFxuICB0cmVhc3VyeUFkZHJlc3M6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1RSRUFTVVJZX0FERFJFU1MgfHwgJycsXG4gIGVuZHBvaW50OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUkNIX0VORFBPSU5UIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnLFxufSk7XG5cbi8vIE1vY2sgaW5pdGlhbCBwb3J0Zm9saW8gZGF0YVxuY29uc3QgSU5JVElBTF9QT1JURk9MSU9fSVRFTVMgPSBbXG4gIHtcbiAgICBuYW1lOiAnUG9seW1vcnBoaWMgTGFicycsXG4gICAgdmFsdWU6IDIwMDAwMCwgLy8gSW5pdGlhbCAkMjAwa1xuICAgIGN1cnJlbnQ6IDEwNDAwMDAsIC8vIDQyMCUgZ3Jvd3RoID0gJDEuMDRNIHRvdGFsXG4gICAgY2hhbmdlOiA0MjAsXG4gICAgZGVzY3JpcHRpb246ICdFbmNyeXB0aW9uIExheWVyJ1xuICB9LFxuICB7XG4gICAgbmFtZTogJ1ZvbHRGaScsXG4gICAgdmFsdWU6IDE1MDAwMCwgLy8gSW5pdGlhbCAkMTUwa1xuICAgIGN1cnJlbnQ6IDUyNTAwMCwgLy8gMjUwJSBncm93dGggPSAkNTI1ayB0b3RhbFxuICAgIGNoYW5nZTogMjUwLFxuICAgIGRlc2NyaXB0aW9uOiAnQml0Y29pbiBWb2xhdGlsaXR5IEluZGV4IG9uIEJpdGNvaW4nXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnTUlYRFRhcGUnLFxuICAgIHZhbHVlOiAxMDAwMDAsIC8vIEluaXRpYWwgJDEwMGtcbiAgICBjdXJyZW50OiAyNTAwMDAsIC8vIDE1MCUgZ3Jvd3RoID0gJDI1MGsgdG90YWxcbiAgICBjaGFuZ2U6IDE1MCxcbiAgICBkZXNjcmlwdGlvbjogJ1BoeWdpdGFsIE11c2ljIGZvciBzdXBlcmZhbnMgLSBkaXNydXB0aW5nIFN0cmVhbWluZydcbiAgfVxuXTtcblxuLy8gU2ltdWxhdGUgcG9ydGZvbGlvIHZhbHVlIGNoYW5nZXNcbmZ1bmN0aW9uIHNpbXVsYXRlUG9ydGZvbGlvQ2hhbmdlKGl0ZW1zOiBQb3J0Zm9saW9bXSk6IFBvcnRmb2xpb1tdIHtcbiAgcmV0dXJuIGl0ZW1zLm1hcChpdGVtID0+ICh7XG4gICAgLi4uaXRlbSxcbiAgICBjdXJyZW50OiBpdGVtLmN1cnJlbnQgKiAoMSArIChNYXRoLnJhbmRvbSgpICogMC4wMiAtIDAuMDEpKSwgLy8gUmFuZG9tIC0xJSB0byArMSUgY2hhbmdlIGluIGN1cnJlbnQgdmFsdWVcbiAgICBjaGFuZ2U6IE51bWJlcigoKGl0ZW0uY3VycmVudCAvIGl0ZW0udmFsdWUgLSAxKSAqIDEwMCkudG9GaXhlZCgxKSksIC8vIFJlY2FsY3VsYXRlIGNoYW5nZSBwZXJjZW50YWdlXG4gIH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU9WVENsaWVudCgpIHtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW25hdkRhdGEsIHNldE5hdkRhdGFdID0gdXNlU3RhdGU8TkFWRGF0YT4oe1xuICAgIHRvdGFsVmFsdWU6ICckMS44MTVNJyxcbiAgICBjaGFuZ2VQZXJjZW50YWdlOiAnKzMwMiUnLFxuICAgIHBvcnRmb2xpb0l0ZW1zOiBJTklUSUFMX1BPUlRGT0xJT19JVEVNU1xuICB9KTtcblxuICAvLyBGZXRjaCBOQVYgZGF0YSBwZXJpb2RpY2FsbHlcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBmZXRjaE5BViA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5hdiA9IGF3YWl0IGFyY2hDbGllbnQuZ2V0Q3VycmVudE5BVigpO1xuICAgICAgICBjb25zdCB0b3RhbFZhbHVlID0gbmF2LnZhbHVlO1xuICAgICAgICBjb25zdCBhdmVyYWdlQ2hhbmdlID0gbmF2LnBvcnRmb2xpb0l0ZW1zLnJlZHVjZSgoc3VtLCBpdGVtKSA9PiBzdW0gKyBpdGVtLmNoYW5nZSwgMCkgLyBuYXYucG9ydGZvbGlvSXRlbXMubGVuZ3RoO1xuICAgICAgICBcbiAgICAgICAgc2V0TmF2RGF0YSh7XG4gICAgICAgICAgdG90YWxWYWx1ZTogYCQkeyh0b3RhbFZhbHVlIC8gMTAwMDAwMCkudG9GaXhlZCgzKX1NYCxcbiAgICAgICAgICBjaGFuZ2VQZXJjZW50YWdlOiBgJHthdmVyYWdlQ2hhbmdlID49IDAgPyAnKycgOiAnJ30ke2F2ZXJhZ2VDaGFuZ2UudG9GaXhlZCgxKX0lYCxcbiAgICAgICAgICBwb3J0Zm9saW9JdGVtczogbmF2LnBvcnRmb2xpb0l0ZW1zLm1hcChpdGVtID0+ICh7XG4gICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogaXRlbS52YWx1ZSxcbiAgICAgICAgICAgIGN1cnJlbnQ6IGl0ZW0udmFsdWUgKiAoMSArIGl0ZW0uY2hhbmdlIC8gMTAwKSxcbiAgICAgICAgICAgIGNoYW5nZTogaXRlbS5jaGFuZ2UsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZ2V0UHJvamVjdERlc2NyaXB0aW9uKGl0ZW0ubmFtZSksXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBOQVY6JywgZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZmV0Y2hOQVYoKTsgLy8gSW5pdGlhbCBmZXRjaFxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoZmV0Y2hOQVYsIDMwMDAwKTsgLy8gVXBkYXRlIGV2ZXJ5IDMwIHNlY29uZHNcblxuICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGJ1eU9WVCA9IHVzZUNhbGxiYWNrKGFzeW5jIChhbW91bnQ6IG51bWJlcikgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICB0cnkge1xuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB3ZSB3b3VsZDpcbiAgICAgIC8vIDEuIEdldCB0aGUgY29ubmVjdGVkIHdhbGxldCBhZGRyZXNzXG4gICAgICAvLyAyLiBXYWl0IGZvciB0aGUgQml0Y29pbiBwYXltZW50IHRyYW5zYWN0aW9uXG4gICAgICAvLyAzLiBVc2UgdGhlIHBheW1lbnQgdHhpZCB0byB2ZXJpZnkgYW5kIGNvbXBsZXRlIHRoZSBwdXJjaGFzZVxuICAgICAgY29uc3QgbW9ja1BheW1lbnRUeGlkID0gJ21vY2tfdHhpZF8nICsgRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFyY2hDbGllbnQuYnV5T1ZUKGFtb3VudCwgbW9ja1BheW1lbnRUeGlkLCAnbW9ja193YWxsZXRfYWRkcmVzcycpO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byBidXkgT1ZUJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlZnJlc2ggTkFWIGRhdGEgYWZ0ZXIgc3VjY2Vzc2Z1bCBwdXJjaGFzZVxuICAgICAgYXdhaXQgYXJjaENsaWVudC5nZXRDdXJyZW50TkFWKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBidXkgT1ZUJyk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgY29uc3Qgc2VsbE9WVCA9IHVzZUNhbGxiYWNrKGFzeW5jIChhbW91bnQ6IG51bWJlcikgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXJjaENsaWVudC5zZWxsT1ZUKGFtb3VudCwgJ21vY2tfd2FsbGV0X2FkZHJlc3MnKTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yIHx8ICdGYWlsZWQgdG8gc2VsbCBPVlQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVmcmVzaCBOQVYgZGF0YSBhZnRlciBzdWNjZXNzZnVsIHNhbGVcbiAgICAgIGF3YWl0IGFyY2hDbGllbnQuZ2V0Q3VycmVudE5BVigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gc2VsbCBPVlQnKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBuYXZEYXRhLFxuICAgIGJ1eU9WVCxcbiAgICBzZWxsT1ZULFxuICB9O1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHByb2plY3QgZGVzY3JpcHRpb25zXG5mdW5jdGlvbiBnZXRQcm9qZWN0RGVzY3JpcHRpb24obmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZGVzY3JpcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICdQb2x5bW9ycGhpYyBMYWJzJzogJ0VuY3J5cHRpb24gTGF5ZXInLFxuICAgICdWb2x0RmknOiAnQml0Y29pbiBWb2xhdGlsaXR5IEluZGV4IG9uIEJpdGNvaW4nLFxuICAgICdNSVhEVGFwZSc6ICdQaHlnaXRhbCBNdXNpYyBmb3Igc3VwZXJmYW5zIC0gZGlzcnVwdGluZyBTdHJlYW1pbmcnLFxuICB9O1xuICByZXR1cm4gZGVzY3JpcHRpb25zW25hbWVdIHx8ICcnO1xufSAiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsIkFyY2hDbGllbnQiLCJhcmNoQ2xpZW50IiwicHJvZ3JhbUlkIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1BST0dSQU1fSUQiLCJ0cmVhc3VyeUFkZHJlc3MiLCJORVhUX1BVQkxJQ19UUkVBU1VSWV9BRERSRVNTIiwiZW5kcG9pbnQiLCJORVhUX1BVQkxJQ19BUkNIX0VORFBPSU5UIiwiSU5JVElBTF9QT1JURk9MSU9fSVRFTVMiLCJuYW1lIiwidmFsdWUiLCJjdXJyZW50IiwiY2hhbmdlIiwiZGVzY3JpcHRpb24iLCJzaW11bGF0ZVBvcnRmb2xpb0NoYW5nZSIsIml0ZW1zIiwibWFwIiwiaXRlbSIsIk1hdGgiLCJyYW5kb20iLCJOdW1iZXIiLCJ0b0ZpeGVkIiwidXNlT1ZUQ2xpZW50IiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsIm5hdkRhdGEiLCJzZXROYXZEYXRhIiwidG90YWxWYWx1ZSIsImNoYW5nZVBlcmNlbnRhZ2UiLCJwb3J0Zm9saW9JdGVtcyIsImZldGNoTkFWIiwibmF2IiwiZ2V0Q3VycmVudE5BViIsImF2ZXJhZ2VDaGFuZ2UiLCJyZWR1Y2UiLCJzdW0iLCJsZW5ndGgiLCJnZXRQcm9qZWN0RGVzY3JpcHRpb24iLCJlcnIiLCJjb25zb2xlIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJidXlPVlQiLCJhbW91bnQiLCJtb2NrUGF5bWVudFR4aWQiLCJEYXRlIiwibm93IiwicmVzdWx0Iiwic3VjY2VzcyIsIkVycm9yIiwibWVzc2FnZSIsInNlbGxPVlQiLCJkZXNjcmlwdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/hooks/useOVTClient.ts\n"));

/***/ }),

/***/ "./src/lib/archClient.ts":
/*!*******************************!*\
  !*** ./src/lib/archClient.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArchClient: function() { return /* binding */ ArchClient; }\n/* harmony export */ });\nclass ArchClient {\n    async verifyBitcoinPayment(txid, expectedAmount) {\n        try {\n            const response = await fetch(\"\".concat(this.endpoint, \"/verify_payment\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    txid,\n                    expected_amount: expectedAmount,\n                    treasury_address: this.treasuryAddress\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to verify payment\");\n            }\n            const result = await response.json();\n            return result.verified;\n        } catch (error) {\n            console.error(\"Payment verification failed:\", error);\n            return false;\n        }\n    }\n    async buyOVT(amount, paymentTxid, walletAddress) {\n        try {\n            // Verify the payment first\n            const isVerified = await this.verifyBitcoinPayment(paymentTxid, amount);\n            if (!isVerified) {\n                throw new Error(\"Payment verification failed\");\n            }\n            // Execute the buyback instruction\n            const response = await fetch(\"\".concat(this.endpoint, \"/buy_ovt\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    program_id: this.programId,\n                    payment_txid: paymentTxid,\n                    amount,\n                    wallet_address: walletAddress\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to execute OVT purchase\");\n            }\n            const result = await response.json();\n            return {\n                success: true,\n                txid: result.txid\n            };\n        } catch (error) {\n            console.error(\"OVT purchase failed:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"Unknown error occurred\"\n            };\n        }\n    }\n    async sellOVT(amount, walletAddress) {\n        try {\n            const response = await fetch(\"\".concat(this.endpoint, \"/sell_ovt\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    program_id: this.programId,\n                    amount,\n                    wallet_address: walletAddress\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to execute OVT sale\");\n            }\n            const result = await response.json();\n            return {\n                success: true,\n                txid: result.txid\n            };\n        } catch (error) {\n            console.error(\"OVT sale failed:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"Unknown error occurred\"\n            };\n        }\n    }\n    async getCurrentNAV() {\n        try {\n            const response = await fetch(\"\".concat(this.endpoint, \"/get_nav\"));\n            if (!response.ok) {\n                throw new Error(\"Failed to fetch NAV\");\n            }\n            return await response.json();\n        } catch (error) {\n            console.error(\"Failed to fetch NAV:\", error);\n            throw error;\n        }\n    }\n    async getTransactionHistory(walletAddress) {\n        try {\n            const response = await fetch(\"\".concat(this.endpoint, \"/transactions?address=\").concat(walletAddress));\n            if (!response.ok) {\n                throw new Error(\"Failed to fetch transaction history\");\n            }\n            return await response.json();\n        } catch (error) {\n            console.error(\"Failed to fetch transaction history:\", error);\n            throw error;\n        }\n    }\n    constructor(config){\n        this.programId = config.programId;\n        this.treasuryAddress = config.treasuryAddress;\n        this.endpoint = config.endpoint;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNQyxNQUFNLEdBQWlCLE9BQWQsSUFBSSxDQUFDQyxRQUFRLEVBQUM7WUFDOUMsSUFBSSxDQUFDRixTQUFTVyxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSUMsTUFBTTtZQUNsQjtZQUNBLE9BQU8sTUFBTVosU0FBU2MsSUFBSTtRQUM1QixFQUFFLE9BQU9FLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHdCQUF3QkE7WUFDdEMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsTUFBTWUsc0JBQXNCVixhQUFxQixFQUE4QjtRQUM3RSxJQUFJO1lBQ0YsTUFBTXJCLFdBQVcsTUFBTUMsTUFDckIsR0FBeUNvQixPQUF0QyxJQUFJLENBQUNuQixRQUFRLEVBQUMsMEJBQXNDLE9BQWRtQjtZQUUzQyxJQUFJLENBQUNyQixTQUFTVyxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSUMsTUFBTTtZQUNsQjtZQUNBLE9BQU8sTUFBTVosU0FBU2MsSUFBSTtRQUM1QixFQUFFLE9BQU9FLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHdDQUF3Q0E7WUFDdEQsTUFBTUE7UUFDUjtJQUNGO0lBN0lBZ0IsWUFBWUMsTUFJWCxDQUFFO1FBQ0QsSUFBSSxDQUFDVCxTQUFTLEdBQUdTLE9BQU9ULFNBQVM7UUFDakMsSUFBSSxDQUFDZCxlQUFlLEdBQUd1QixPQUFPdkIsZUFBZTtRQUM3QyxJQUFJLENBQUNSLFFBQVEsR0FBRytCLE9BQU8vQixRQUFRO0lBQ2pDO0FBc0lGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYXJjaENsaWVudC50cz8zZDllIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ0BvbW5pc2F0L2xhc2VyZXllcyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFyY2hUcmFuc2FjdGlvbiB7XHJcbiAgdHhpZDogc3RyaW5nO1xyXG4gIGFtb3VudDogbnVtYmVyO1xyXG4gIGNvbmZpcm1hdGlvbnM6IG51bWJlcjtcclxuICB0aW1lc3RhbXA6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBOQVZVcGRhdGUge1xyXG4gIHRpbWVzdGFtcDogbnVtYmVyO1xyXG4gIHZhbHVlOiBudW1iZXI7XHJcbiAgcG9ydGZvbGlvSXRlbXM6IHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHZhbHVlOiBudW1iZXI7XHJcbiAgICBjaGFuZ2U6IG51bWJlcjtcclxuICB9W107XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBBcmNoQ2xpZW50IHtcclxuICBwcml2YXRlIHByb2dyYW1JZDogc3RyaW5nO1xyXG4gIHByaXZhdGUgdHJlYXN1cnlBZGRyZXNzOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBlbmRwb2ludDogc3RyaW5nO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihjb25maWc6IHtcclxuICAgIHByb2dyYW1JZDogc3RyaW5nO1xyXG4gICAgdHJlYXN1cnlBZGRyZXNzOiBzdHJpbmc7XHJcbiAgICBlbmRwb2ludDogc3RyaW5nO1xyXG4gIH0pIHtcclxuICAgIHRoaXMucHJvZ3JhbUlkID0gY29uZmlnLnByb2dyYW1JZDtcclxuICAgIHRoaXMudHJlYXN1cnlBZGRyZXNzID0gY29uZmlnLnRyZWFzdXJ5QWRkcmVzcztcclxuICAgIHRoaXMuZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnQ7XHJcbiAgfVxyXG5cclxuICBhc3luYyB2ZXJpZnlCaXRjb2luUGF5bWVudCh0eGlkOiBzdHJpbmcsIGV4cGVjdGVkQW1vdW50OiBudW1iZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5lbmRwb2ludH0vdmVyaWZ5X3BheW1lbnRgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIHR4aWQsXHJcbiAgICAgICAgICBleHBlY3RlZF9hbW91bnQ6IGV4cGVjdGVkQW1vdW50LFxyXG4gICAgICAgICAgdHJlYXN1cnlfYWRkcmVzczogdGhpcy50cmVhc3VyeUFkZHJlc3MsXHJcbiAgICAgICAgfSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHZlcmlmeSBwYXltZW50Jyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdC52ZXJpZmllZDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1BheW1lbnQgdmVyaWZpY2F0aW9uIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGJ1eU9WVChcclxuICAgIGFtb3VudDogbnVtYmVyLFxyXG4gICAgcGF5bWVudFR4aWQ6IHN0cmluZyxcclxuICAgIHdhbGxldEFkZHJlc3M6IHN0cmluZ1xyXG4gICk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyB0eGlkPzogc3RyaW5nOyBlcnJvcj86IHN0cmluZyB9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBWZXJpZnkgdGhlIHBheW1lbnQgZmlyc3RcclxuICAgICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IHRoaXMudmVyaWZ5Qml0Y29pblBheW1lbnQocGF5bWVudFR4aWQsIGFtb3VudCk7XHJcbiAgICAgIGlmICghaXNWZXJpZmllZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGF5bWVudCB2ZXJpZmljYXRpb24gZmFpbGVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEV4ZWN1dGUgdGhlIGJ1eWJhY2sgaW5zdHJ1Y3Rpb25cclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmVuZHBvaW50fS9idXlfb3Z0YCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBwcm9ncmFtX2lkOiB0aGlzLnByb2dyYW1JZCxcclxuICAgICAgICAgIHBheW1lbnRfdHhpZDogcGF5bWVudFR4aWQsXHJcbiAgICAgICAgICBhbW91bnQsXHJcbiAgICAgICAgICB3YWxsZXRfYWRkcmVzczogd2FsbGV0QWRkcmVzcyxcclxuICAgICAgICB9KSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZXhlY3V0ZSBPVlQgcHVyY2hhc2UnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgdHhpZDogcmVzdWx0LnR4aWQsXHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdPVlQgcHVyY2hhc2UgZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvciBvY2N1cnJlZCcsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzZWxsT1ZUKFxyXG4gICAgYW1vdW50OiBudW1iZXIsXHJcbiAgICB3YWxsZXRBZGRyZXNzOiBzdHJpbmdcclxuICApOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgdHhpZD86IHN0cmluZzsgZXJyb3I/OiBzdHJpbmcgfT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmVuZHBvaW50fS9zZWxsX292dGAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgcHJvZ3JhbV9pZDogdGhpcy5wcm9ncmFtSWQsXHJcbiAgICAgICAgICBhbW91bnQsXHJcbiAgICAgICAgICB3YWxsZXRfYWRkcmVzczogd2FsbGV0QWRkcmVzcyxcclxuICAgICAgICB9KSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZXhlY3V0ZSBPVlQgc2FsZScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICB0eGlkOiByZXN1bHQudHhpZCxcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ09WVCBzYWxlIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Q3VycmVudE5BVigpOiBQcm9taXNlPE5BVlVwZGF0ZT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmVuZHBvaW50fS9nZXRfbmF2YCk7XHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBOQVYnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIE5BVjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25IaXN0b3J5KHdhbGxldEFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8QXJjaFRyYW5zYWN0aW9uW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgICAgYCR7dGhpcy5lbmRwb2ludH0vdHJhbnNhY3Rpb25zP2FkZHJlc3M9JHt3YWxsZXRBZGRyZXNzfWBcclxuICAgICAgKTtcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHRyYW5zYWN0aW9uIGhpc3RvcnknKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIHRyYW5zYWN0aW9uIGhpc3Rvcnk6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcbn0gIl0sIm5hbWVzIjpbIkFyY2hDbGllbnQiLCJ2ZXJpZnlCaXRjb2luUGF5bWVudCIsInR4aWQiLCJleHBlY3RlZEFtb3VudCIsInJlc3BvbnNlIiwiZmV0Y2giLCJlbmRwb2ludCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImV4cGVjdGVkX2Ftb3VudCIsInRyZWFzdXJ5X2FkZHJlc3MiLCJ0cmVhc3VyeUFkZHJlc3MiLCJvayIsIkVycm9yIiwicmVzdWx0IiwianNvbiIsInZlcmlmaWVkIiwiZXJyb3IiLCJjb25zb2xlIiwiYnV5T1ZUIiwiYW1vdW50IiwicGF5bWVudFR4aWQiLCJ3YWxsZXRBZGRyZXNzIiwiaXNWZXJpZmllZCIsInByb2dyYW1faWQiLCJwcm9ncmFtSWQiLCJwYXltZW50X3R4aWQiLCJ3YWxsZXRfYWRkcmVzcyIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwic2VsbE9WVCIsImdldEN1cnJlbnROQVYiLCJnZXRUcmFuc2FjdGlvbkhpc3RvcnkiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/lib/archClient.ts\n"));

/***/ })

});